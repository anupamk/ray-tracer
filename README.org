#+TITLE: SMRT : Smol Ray Tracer
#+Author: Anupam Kapoor
#+EMAIL: anupam.kapoor@gmail.com
#+OPTIONS: ^:nil _:nil
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

* Description

  This is a rendition in C++, of a CPU based, [[https://en.wikipedia.org/wiki/Ray_tracing_(graphics)][raytracer]] without using
  /*any*/ external graphics libraries f.e. OpenGL etc. [[Generated Images][Rendered images]]
  are saved in [[http://netpbm.sourceforge.net/doc/ppm.html][PPM]] formatted files. These can be subsequently viewed
  via plethora of image viewers.

* Development Overview

  This CPU based [[https://en.wikipedia.org/wiki/Ray_tracing_(graphics)][raytracer]] is /approximately/ based on the one
  described in Jamis Buck's book [[https://www.goodreads.com/book/show/39933047-the-ray-tracer-challenge][The Ray Tracer Challenge]]. The book
  itself is programming language agnostic, and follows a test driven
  development or [[https://en.wikipedia.org/wiki/Test-driven_development][TDD]] style to motivate its (raytracer's)
  construction.

** What Is TDD ?

   In TDD style of development, developers are expected to write unit
   tests before they write code. Thus, for example, before writing an
   implementation of a class, developers are expected to write unit
   tests for /expected behavior/ of the class.

   Ofcourse, initially, none of the tests would pass since there is
   no code for the class. Developer then works through the tests one
   at a time, writing enough code for each test to pass. When all
   tests pass, the class is considered done.

** Why I Don't Like It

   Although I am a strong believer in writing /*unit tests*/, but
   somehow the idea of TDD doesn't sit too well with me. It just seems
   too /incremental/, and smacks of prioritizing getting specific
   /features/ done, rather than finding the *best overall
   design*. /IMHO/ with this /*tactical*/ style of development, it is
   quite easy to end up with a mess.

** Moving Along...

   Having said that, I have tried to follow the /spirit/ of the text in
   this implementation. Ideas from the book are considered
   /*informative*/ rather than /*normative*/. Deviations in
   implementation, which are hopefully few and far between, are made
   with an intent of:

      * either increasing rendering performance (on a /cpu/ ? hah !)
        and

      * increasing visual appeal of generated scenes.

   A few examples of the former include:

      * support for [[Notes On MultiThreading][multi-threaded]] rendering


      * storing pre-computed inverse-transformation matrices for
        various supported primitives, as opposed to re-computing them
        for each pixel during rendering.


      * avoiding memory-allocations during rendering operations

   Example of latter include:

      * support for both applying image based as well as procedural
        ([[https://en.wikipedia.org/wiki/Perlin_noise][perlin noise]]) textures on various primitives supported.

   More tweaks and enhancements are planned. See the [[./TODO.org][included]] file for
   details.

* Building + Running

** Machine Configuration

   Timings for operations, rendering benchmarks etc. that are
   sprinkled fairly liberally throughout this document, are all from
   experiments performed on my current desktop machine.

   This machine, has been my workhorse for more than a decade. It has
   this [[https://www.gigabyte.com/Motherboard/GA-EX58-UD4P-rev-10#ov][motherboard]], with RAM maxed out at 24G. The [[https://ark.intel.com/content/www/us/en/ark/products/37147/intel-core-i7-920-processor-8m-cache-2-66-ghz-4-80-gt-s-intel-qpi.html][CPU]] is =Intel Core
   i7 920= clocking at =2.67 Ghz= and the root filesystem is on a [[https://www.samsung.com/semiconductor/minisite/ssd/product/consumer/850evo/][1 TB
   SSD]].

   Overall, from today's standards, the specs on the machine are
   positively /*pleistocenic*/.

   If you are looking for the gory details here they are:

*** CPU
    #+begin_src
      anupam@virat ~
      % lscpu

      Architecture:            x86_64
        CPU op-mode(s):        32-bit, 64-bit
        Address sizes:         36 bits physical, 48 bits virtual
        Byte Order:            Little Endian
      CPU(s):                  8
        On-line CPU(s) list:   0-7
      Vendor ID:               GenuineIntel
        Model name:            Intel(R) Core(TM) i7 CPU         920  @ 2.67GHz
          CPU family:          6
          Model:               26
          Thread(s) per core:  2
          Core(s) per socket:  4
          Socket(s):           1
          Stepping:            4
          Frequency boost:     enabled
          CPU max MHz:         2793.0000
          CPU min MHz:         1596.0000
          BogoMIPS:            5331.62
          Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts ac
                               pi mmx fxsr sse sse2 ht tm pbe syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts
                                rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni dtes64 monitor ds_cpl vmx es
                               t tm2 ssse3 cx16 xtpr pdcm sse4_1 sse4_2 popcnt lahf_lm pti tpr_shadow vnmi flexpriori
                               ty ept vpid dtherm ida
      Virtualization features:
        Virtualization:        VT-x
      Caches (sum of all):
        L1d:                   128 KiB (4 instances)
        L1i:                   128 KiB (4 instances)
        L2:                    1 MiB (4 instances)
        L3:                    8 MiB (1 instance)
      NUMA:
        NUMA node(s):          1
        NUMA node0 CPU(s):     0-7

        .....
    #+end_src

*** System Memory
    #+begin_src
      anupam@virat ~
      % sudo lshw -short -C memory
      H/W path           Device  Class       Description
      ==================================================
      /0/0                       memory      128KiB BIOS
      /0/4/c                     memory      64KiB L1 cache
      /0/4/d                     memory      8MiB L2 cache
      /0/17                      memory      24GiB System Memory
      /0/17/0                    memory      4GiB DIMM 400 MHz (2.5 ns)
      /0/17/1                    memory      4GiB DIMM 400 MHz (2.5 ns)
      /0/17/2                    memory      4GiB DIMM 400 MHz (2.5 ns)
      /0/17/3                    memory      4GiB DIMM 400 MHz (2.5 ns)
      /0/17/4                    memory      4GiB DIMM 400 MHz (2.5 ns)
      /0/17/5                    memory      4GiB DIMM 400 MHz (2.5 ns)
    #+end_src

*** SSD Specs
    #+begin_src
      % sudo hdparm -I /dev/sdc

      /dev/sdc:

      ATA device, with non-removable media
              Model Number:       Samsung SSD 850 EVO 1TB
              Serial Number:      S2PWNX0J202193D
              Firmware Revision:  EMT02B6Q
              Transport:          Serial, ATA8-AST, SATA 1.0a, SATA II Extensions, SATA Rev 2.5, SATA Rev 2.6, SATA Rev 3.0
      ....
    #+end_src

** Building

   I am using [[https://cmake.org/][cmake]] for building the whole thing. Each scene is
   rendered using its own executable. All scenes that can be rendered
   are available [[Generated Images][here]].

   Unsurprisingly, in the table, the column named =Executable Name= is
   the name of the executable that produces the displayed image.

** Why You Do This ?

   Instead of using 1 executable per scene, other approaches are also
   possible. One possibility is to have the entire scene described
   using a /scene configuration file/. The renderer can now have two
   distinct parts as follows:

       1. parse the scene, and create objects with properties
          described therein and

       2. render the scene

   [[https://en.wikipedia.org/wiki/YAML][YAML]] or maybe even [[https://en.wikipedia.org/wiki/Lua_(programming_language)][LUA]] can be used for this ? Going down that path
   seems like an un-necessary distraction for /starters/. One would
   presumably expend considerable time and energy activities which
   are far removed from the /*actual*/ raytracer itself.

   IMHO, having a /functionaly correct/ and /performant/ raytracer
   /*first*/, is a superior approach. Once that is done, enhancements
   to support scene specifications via a description language can be
   easily added.

** How Do I /Build/ It ... Please ?

   Overall sequence of steps for building executables and tests are as
   follows:

    1. Create a directory where all generated files will be
       placed. For illustration purposes, this is called =build=. Go
       there and generate the makefiles:

       #+begin_src
         $ .../> mkdir build && cd build
         $ .../build> cmake .. -G "Unix Makefiles"
       #+end_src

    2. Now we can run either:

       #+begin_src
         $ .../build> make
       #+end_src

       for single threaded build. Faster parallelized builds are also
       possible, thus f.e., you can do:

       #+begin_src
         $ .../build> make -j <N>
         N == number of cpu-cores you want to use
       #+end_src

       Either of the steps, when completed successfully, will generate
       executables as well as the tests. These are respectively
       available in:

      #+begin_src
        $ .../build> ./src
        $ .../build> ./tests
      #+end_src

      Can we run the executables now ? Nope, read on brave soldier !

    3. <<convert-textures>> Convert textures from JPEG to P3 format

       SMRT's texture support is quite spartan with respect to
       supported image formats. Currently, it just supports PPM based
       (or to be pedantic [[https://en.wikipedia.org/wiki/Netpbm#PPM_example][P3]] formatted) textures.

       PPM formatted files, though easy to work with, are quite
       profligate with their space usage. This repository therefore
       packages textures as JPEG formatted files.

       Of course, before these can be used, they must be converted to
       P3 format. This can be accomplished quite easily though. For
       example, using the venerable [[https://imagemagick.org/index.php][Image Magick]] we can do this:

       #+begin_src
         $ .../build> convert ../textures/nasa-blue-marble.jpg -compress none ../textures/nasa-blue-marble.ppm
         $ .../build> ls -l --human ../textures/nasa-blue-marble.jpg ../textures/nasa-blue-marble.ppm

         -rw-r--r-- 1 anupam anupam 1.7M Mar 20 16:49 ../textures/nasa-blue-marble.jpg
         -rw-r--r-- 1 anupam anupam  76M Jul  6 14:51 ../textures/nasa-blue-marble.ppm
       #+end_src

       The, =-compress none= stanza above, specifies that we want to
       generate ascii formatted PPM files. As you can see the
       difference in file sizes between the two is quite significant
       indeed.

       Texture loading speed is not /too shabby/ though. For the above
       case, on [[Machine Configuration][my machine]] I get:

       #+begin_src
         INFO   | 2021-07-06 15:26:16.235 | /home/anupam/source-code/c++/ray-tracer/src/render_nasa_blue_earth.cpp : 00125 | begin loading texture:../textures/nasa-blue-marble.ppm
         INFO   | 2021-07-06 15:26:16.721 | /home/anupam/source-code/c++/ray-tracer/src/render_nasa_blue_earth.cpp : 00130 | end loading texture:../textures/nasa-blue-marble.ppm
       #+end_src

       Which is =486ms= for loading a =76 MB= P3 formatted file into a
       texture that is then further processed.

       /Now/ we are /*all set*/ for running the generated executables
       and tests.

** Running

    Once the build process is complete, and the textures have all been
    [[convert-textures][converted]] you can run any executable to render the [[Generated   Images][scenes]].

*** Rendering The Scenes

    Thus for example, to render the scene shown [[render-with-t3r][here]], you can do this:

    #+begin_src
      $ .../build> src/render-with-t3

      INFO   | 2021-07-10 21:33:53.267 | /home/anupam/source-code/c++/ray-tracer/src/render_with_t3r.cpp : 00066 | canvas details : {width (pixels): 1280, height (pixels): 1024, destination: 'render-with-t3r.ppm'}
      INFO   | 2021-07-10 21:33:53.267 | /home/anupam/source-code/c++/ray-tracer/src/render_with_t3r.cpp : 00078 | benchmark details: '{iterations: 10, throw-away: 3, num_times: 0}'
      INFO   | 2021-07-10 21:33:53.267 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0001 / 0013
      INFO   | 2021-07-10 21:34:04.441 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0002 / 0013
      INFO   | 2021-07-10 21:34:16.013 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0003 / 0013
      INFO   | 2021-07-10 21:34:27.522 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0004 / 0013
      INFO   | 2021-07-10 21:34:39.192 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0005 / 0013
      INFO   | 2021-07-10 21:34:50.478 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0006 / 0013
      INFO   | 2021-07-10 21:35:01.974 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0007 / 0013
      INFO   | 2021-07-10 21:35:13.250 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0008 / 0013
      INFO   | 2021-07-10 21:35:24.565 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0009 / 0013
      INFO   | 2021-07-10 21:35:35.777 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0010 / 0013
      INFO   | 2021-07-10 21:35:47.038 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0011 / 0013
      INFO   | 2021-07-10 21:35:58.269 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0012 / 0013
      INFO   | 2021-07-10 21:36:09.739 | /home/anupam/source-code/c++/ray-tracer/common/include/benchmark.hpp : 00074 | running 0013 / 0013
      INFO   | 2021-07-10 21:36:21.445 | /home/anupam/source-code/c++/ray-tracer/src/render_with_t3r.cpp : 00087 | benchmark details : {mean (ms): '11312', standard-deviation (ms): '00141'}


      $ .../build> ls -l render-with-t3r.ppm
      -rw-r--r-- 1 anupam anupam 12786381 Jul 10 21:36 render-with-t3r.ppm
    #+end_src

    Since benchmarking is enabled (not a runtime option !) we see
    quite a chatty output from the renderer.

    Benchmarking is done with following parameters:

    #+begin_src
      INFO   | 2021-07-10 21:33:53.267 | /home/anupam/source-code/c++/ray-tracer/src/render_with_t3r.cpp : 00078 | benchmark details: '{iterations: 10, throw-away: 3, num_times: 0}'
    #+end_src

    Thus a total of =13= rounds of rendering are done, out which =10=
    samples are chosen (for statistics computation), and (first) =3=
    of those are discarded.

    Benchmark routines allow to repeat the entire computation multiple
    times as well (to discount cache effects etc.). This is the
    =num_times= field in the above log. However, we are not doing that
    here.

    In any case, the code for benchmarking looks something like this:

    #+begin_src c++
              /// --------------------------------------------------------------------
              /// benchmark the render as follows:
              ///   - record timings for 'num_iterations' renderings
              ///   - from these records, discard 'num_discards' samples
              /// and then compute mean and standard-deviation
              auto const num_iterations = 10;
              auto const num_discards   = 3;
              Benchmark<> render_bm(num_iterations, num_discards);
              LOG_INFO("benchmark details: '%s'", render_bm.stringify().c_str());
    #+end_src

    The result are:

    #+begin_src
      INFO   | 2021-07-10 21:36:21.445 | /home/anupam/source-code/c++/ray-tracer/src/render_with_t3r.cpp : 00087 | benchmark details : {mean (ms): '11312', standard-deviation (ms): '00141'}
    #+end_src

    This shows, that the renderer (multi-threaded in this case) took a
    [[https://en.wikipedia.org/wiki/Mean][mean]] of =11312 ms= to render the scene, and this has a
    [[https://en.wikipedia.org/wiki/Standard_deviation][standard-deviation]] of =141 ms=.

    For the single-threaded renderer, on the other hand, we get this:

    #+begin_src
      INFO   | 2021-07-10 21:28:41.378 | /home/anupam/source-code/c++/ray-tracer/src/render_with_t3r.cpp : 00088 | benchmark details : {mean (ms): '32249', standard-deviation (ms): '00277'}
    #+end_src

    which has corresponding numbers at =32249 ms= and =00277 ms=
    respectively.

    For this specific case, therefore, the multi threaded renderer is
    better than the single threaded one by a factor of about =2.85=.

    Larger scenes would ofcourse have larger /absolute/ numbers, but
    the ratio between the two (renderers) should be /about/ the
    same.

    For example, a =5120x4096= pixel render for the same scene (larger
    by a factor of =16=), takes:

    * ={mean (ms):'190032', standard-deviation (ms): '05703'}= for the
      multi threaded case, and

    * ={mean (ms): '533484', standard-deviation (ms): '09607'}= for
      the single threaded case

    The ratio of single-threaded to multi-threaded rendering is =2.8=,
    which seems to be in line with the expectations above.

*** Running tests

    SMRT has a /decent/ suite of tests covering most of the crucial
    areas of the program. Tests can be run either individually:

       #+begin_src
         $ .../build> ./tests/<name-of-a-test>
       #+end_src

    or all at once:

       #+begin_src
         $ .../build> make test
       #+end_src

    Tests are included for things like: tuples, colors, canvas
    operations i.e. reading & writing, matrix operations (including
    transformations), camera & ray primitives, shapes and their
    intersection with rays, phong illumination model tests,
    reflection, refraction and transparency tests etc. etc.

    Usually, after making a change f.e. adding support for a new shape
    primitive etc. I do the latter than the former. When the latter
    fails, then I go and dig deeper...

* Notes On MultiThreading

  Pixels comprising an image generated as part of a scene, are placed
  on a canvas. Canvas parameters are either manually specified or are
  computed from pinhole camera (configuration) through which the
  entire scene is observed. These include things like horizontal image
  size, vertical image size, field of view, pixel size etc.

  Rendering on the canvas can be done either by a single thread of
  execution or can proceed with multiple threads. Multi threaded
  rendering utilizes all available hardware cores on the
  system.


** SMRT's Approach To Multi Threaded Rendering

   SMRT's approach for multi threaded rendering is now described:

   For multi-threaded rendering SMRT uses a multi producer multi
   consumer lockless (MPMC) 'work' queue. This is used for dispatching
   'work items' to individual renderers.

   A 'work item' comprises 'N' pixels worth of rendering in a specific
   row of pixels in the image, and is computed based on number of
   available hardware cores on the machine.

   Thus, for example, if a machine has 8 physical cores, and the image
   is 1280x1024 pixels, 'N' would be '1024 / 8 == 128' pixels. A single
   row is rendered by hopefully in parallel by each h/w thread.

   The overall scheme is pretty straightforward and proceeds as
   follows:

     1. Based on horizontal pixel size of the image, and available
        cores, first compute total pixels per thread.

     2. Fill up the lockless queue with render work items, each of
        which contains an instance of a render work, and these look
        like this:

        #+begin_src c++
         /// --------------------------------------------------------------------
         /// a render-work item is a ray at a specific place on the canvas
         class render_work_item
         {
             public:
                 uint32_t x;
                 uint32_t y;
                 ray_t r;
         };

         /// --------------------------------------------------------------------
         /// a bunch of render-work items is what is what gets handled by a
         /// single rendering thread
         class render_work_items
         {
             public:
                 std::vector<render_work_item> work_list;
         };
        #+end_src

     3. For a camera 'C', the main thread now fills up the work queue
        with rendering work like so:

        #+begin_src c++
         int const TOTAL_PIXELS_PER_THREAD = C.hsize() / MAX_RENDERING_THREADS;
         int const TOTAL_PIXELS_PER_THREAD = C.hsize() / MAX_RENDERING_THREADS;
         CQ::ConcurrentQueue<render_work_items> work_queue(TOTAL_PIXELS_PER_THREAD * C.vsize());

         /// ------------------------------------------------------------
         /// generate work for the workers...
         for (uint32_t y = 0; y < C.vsize(); y++) {
                 for (uint32_t x = 0; x < C.hsize(); x += TOTAL_PIXELS_PER_THREAD) {
                         for (int i = 0; i < TOTAL_PIXELS_PER_THREAD; i++) {
                           ...
                         }
                 }
         }
        #+end_src

        It then starts all the rendering threads, and waits for them to
        join.

        #+begin_src c++
         /// ------------------------------------------------------------
         /// start the coloring threads
         std::vector<std::thread> rendering_threads(MAX_RENDERING_THREADS);
         for (auto i = 0; i < MAX_RENDERING_THREADS; i++) {
                 rendering_threads[i] = std::thread(coloring_worker,            /// rendering-function
                                                    i,                          /// thread-id
                                                    std::ref(work_queue),       /// work-queue
                                                    W,                          /// the world
                                                    std::ref(rendered_canvas)); /// canvas
         }

         /// wait for all of them to terminate
         std::for_each(rendering_threads.begin(), rendering_threads.end(),
                       std::mem_fn(&std::thread::join));
        #+end_src

     4. Each of the 'coloring_worker' picks a work item from the queue,
        and renders all the pixels specified in the work item.

        Since all work items (that make up the entire canvas) contain
        disjoint set of pixels, no locking is required.

     5. When a renderer is done with the current work item, it picks up
        the next one from the queue. This goes on, till all the work
        items in the queue are done.

        When that happens across all renderers, complete image is
        rendered.

** Why this particular approach ?

     Scenes normally have varying amount of detail, therefore, some
     threads will finish early as compared to their brethren. But then
     they get to pick the next available work item, which may tip the
     balance. On the whole though, number of work items handled per
     thread (through the entire course of rendering the scene) should
     /*approximately*/ be the same.

     This scheme _seems_ to be a better than slicing up the entire
     scene into multiple stripes, and then letting each of the threads
     handle a specific stripe. Depending on the scene, some threads
     might get a 'free-ride' by just rendering stripes that contain
     few non-black pixels.

* Generated Images

  Click on the low resolution images here to see the same image in
  higher resolution. All scenes that are rendered, generate a
  /*1280x1024*/ pixel image.

  Moreover the =Time To Render= column (when available) shows the time
  in milli-seconds it took to render the scene on [[Machine Configuration][this]] machine. First
  number is with multi-threaded (MT) renderer, and the second one is
  with single-threaded (ST) renderer.

** 'Getting Your Feet Wet' Images

   These are quite trivial constructions, but they are very useful to
   test out various rudimentary aspects of the ray tracer. This
   includes (but is not limited to),

   * basic ray, tuple, vector and matrix implementatations
   * ppm file generation routines
   * different transformations applied to generated scenes

   |------------+-----------------------------------------------------------------------------+-------------------+------------------------------------------------------|
   | Serial No. | Description                                                                 | Executable Name   | Image                                                |
   |------------+-----------------------------------------------------------------------------+-------------------+------------------------------------------------------|
   |          1 | Display trajectory of a virtual projectile shot through a cannon.           | virtual-cannon    | [[file:./generated-images/virtual-cannon.png][file:./generated-images/virtual-cannon-lowres.png]]    |
   |------------+-----------------------------------------------------------------------------+-------------------+------------------------------------------------------|
   |          2 | Display clock dials on a clock face through trivial matrix transformations. | clock-dial        | [[file:./generated-images/clock-face.png][file:./generated-images/clock-face-lowres.png]]        |
   |------------+-----------------------------------------------------------------------------+-------------------+------------------------------------------------------|
   |          3 | Silhouette of a sphere.                                                     | sphere-silhouette | [[file:./generated-images/sphere-silhouette.png][file:./generated-images/sphere-silhouette-lowres.png]] |
   |------------+-----------------------------------------------------------------------------+-------------------+------------------------------------------------------|


** Simple Shapes

   This is where things are getting slightly more involved. Here we
   have examples of different shapes using [[https://en.wikipedia.org/wiki/Phong_reflection_model][Phong Reflection Model]] to
   generate /slightly/ more realistic looking images.

   Rendering is now taking more time, and there is support for both
   single and multi-threaded rendering. Generally, a single source
   file can switch between single-threaded and multi-threaded
   rendering (with trivial code changes).

   See for yourself !

   |------------+--------------------------------------------------------------------------------------------------------------------------------+-------------------------------------+------------------------+---------------------------------------------------------|
   | Serial No. | Description                                                                                                                    | Time To Render (MT/ST) Milliseconds | Executable Name        | Image                                                   |
   |------------+--------------------------------------------------------------------------------------------------------------------------------+-------------------------------------+------------------------+---------------------------------------------------------|
   |          1 | Phong shading of a scaled sphere.                                                                                              | 649/603                             | phong-sphere           | [[file:./generated-images/phong-sphere.png][file:./generated-images/phong-sphere-lowres.png]]         |
   |------------+--------------------------------------------------------------------------------------------------------------------------------+-------------------------------------+------------------------+---------------------------------------------------------|
   |          2 | Make a simple scene with a bunch of spheres, their shadows, and walls. Walls are /*huge*/ spheres actually.                    | 1828/3991                           | making-a-scene         | [[file:./generated-images/render-world-simple.png][file:./generated-images/render-world-simple-lowres.png]]  |
   |------------+--------------------------------------------------------------------------------------------------------------------------------+-------------------------------------+------------------------+---------------------------------------------------------|
   |          3 | Still a simple scene afaics. Wall are planes this time around, and thus rendering is fasta !                                   | 1476/3156                           | render-with-plane      | [[file:./generated-images/render-with-plane.png][file:./generated-images/render-with-plane-lowres.png]]    |
   |------------+--------------------------------------------------------------------------------------------------------------------------------+-------------------------------------+------------------------+---------------------------------------------------------|
   |          4 | This is just showing off !!! Render a simple scene with multiple objects, light sources, shadows and different patterns.       | 1035/2196                           | render-with-patterns   | [[file:./generated-images/render-with-patterns.png][file:./generated-images/render-with-patterns-lowres.png]] |
   |------------+--------------------------------------------------------------------------------------------------------------------------------+-------------------------------------+------------------------+---------------------------------------------------------|
   |          5 | How do perline noise textures look like ?                                                                                      | -                                   | render-textures        | [[file:./generated-images/simple-noise.png][file:./generated-images/simple-noise-lowres.png]]         |
   |------------+--------------------------------------------------------------------------------------------------------------------------------+-------------------------------------+------------------------+---------------------------------------------------------|
   |          6 | Render a scene with perlin noise. Kinda weird looking for sure.                                                                | 1423/3633                           | render-with-textures   | [[file:./generated-images/render-with-textures.png][file:./generated-images/render-with-textures-lowres.png]] |
   |------------+--------------------------------------------------------------------------------------------------------------------------------+-------------------------------------+------------------------+---------------------------------------------------------|
   |          7 | Probably the first scene everyone renders after adding support for texture mapping. Notice that not everything casts a shadow. | 1133/2940                           | render-nasa-blue-earth | [[file:./generated-images/render-blue-earth.png][file:./generated-images/render-blue-earth-lowres.png]]    |
   |------------+--------------------------------------------------------------------------------------------------------------------------------+-------------------------------------+------------------------+---------------------------------------------------------|


** Things are Getting Interesting Now ?

   Things are now getting interesting. Support is now available for
   refractions, reflections and transparency effects.

   |------------+----------------------------------------------------------------------------------------------------------+-------------------------------------+-------------------------------------+---------------------------------------------------------|
   | Serial No. | Description                                                                                              | Time To Render (MT/ST) Milliseconds | Executable Name                     | Image                                                   |
   |------------+----------------------------------------------------------------------------------------------------------+-------------------------------------+-------------------------------------+---------------------------------------------------------|
   |          1 | A reddish looking /planet/ with reflections in /water/.                                                  | 1331/3226                           | render-with-reflections             | [[file:./generated-images/render-red-planet.png][file:./generated-images/render-red-planet-lowres.png]]    |
   |------------+----------------------------------------------------------------------------------------------------------+-------------------------------------+-------------------------------------+---------------------------------------------------------|
   |          2 | A slightly sophisticated scene with transparency, reflections and refractions. Looks kinda cool overall. | 11016/33027                         | <<render-with-t3r>> render-with-t3r | [[file:./generated-images/render-with-t3r.png][file:./generated-images/render-with-t3r-lowres.png]]      |
   |------------+----------------------------------------------------------------------------------------------------------+-------------------------------------+-------------------------------------+---------------------------------------------------------|
   |          3 | A glass sphere, containing a hollow sphere within itself.                                                | 17491/28923                         | nested-glass-spheres                | [[file:./generated-images/nested-glass-spheres.png][file:./generated-images/nested-glass-spheres-lowres.png]] |
   |------------+----------------------------------------------------------------------------------------------------------+-------------------------------------+-------------------------------------+---------------------------------------------------------|


** Add Cube Support

   Cube support is now available in the renderer. This includes
   mapping cross-format or skybox images onto a cube as well.

   Lets see how that looks like

   |------------+---------------------------------------------------------------+-------------------------------------+------------------+------------------------------------------------------|
   | Serial No. | Description                                                   | Time To Render (MT/ST) Milliseconds | Executable Name  | Image                                                |
   |------------+---------------------------------------------------------------+-------------------------------------+------------------+------------------------------------------------------|
   |          1 | A cubic pattern on a plane.                                   | -                                   | cube-align-check | [[file:./generated-images/align-check-plane.png][file:./generated-images/align-check-plane-lowres.png]] |
   |------------+---------------------------------------------------------------+-------------------------------------+------------------+------------------------------------------------------|
   |          2 | Texture mapping at cube corners.                              | -                                   | cube-checkered   | [[file:./generated-images/checker-cubes.png][file:./generated-images/checker-cubes-lowres.png]]     |
   |------------+---------------------------------------------------------------+-------------------------------------+------------------+------------------------------------------------------|
   |          3 | A cross-format texture mapped on a slightly transformed cube. | 752/833                             | cube-skybox      | [[file:./generated-images/skybox.png][file:./generated-images/skybox-lowres.png]]            |
   |------------+---------------------------------------------------------------+-------------------------------------+------------------+------------------------------------------------------|


** /Miscellaneous/ Scenery

   Ok, so if you are getting bored on a slow weekend, what do you do ?
   Raytracing is the right and only answer I suppose...

   |------------+--------------------------------------------------------------------------+-------------------------------------+------------------+-----------------------------------------------------|
   | Serial No. | Description                                                              | Time To Render (MT/ST) Milliseconds | Executable Name  | Image                                               |
   |------------+--------------------------------------------------------------------------+-------------------------------------+------------------+-----------------------------------------------------|
   |          1 | Earth in a transparent cube, for some cool looking effects.              | 8634/21723                          | cube-scene       | [[file:./generated-images/cube-scene.png][file:./generated-images/cube-scene-lowres.png]]       |
   |------------+--------------------------------------------------------------------------+-------------------------------------+------------------+-----------------------------------------------------|
   |          2 | A bunch of cubes in a texture mapped /starfield/ for something bizzare ? | 26995/86411                         | cube-light-scene | [[file:./generated-images/cube-light-scene.png][file:./generated-images/cube-light-scene-lowres.png]] |
   |------------+--------------------------------------------------------------------------+-------------------------------------+------------------+-----------------------------------------------------|
