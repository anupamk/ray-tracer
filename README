 Description
=============
Simple ray-tracer with some tests

    A. Building
       ----------
       Note: We are using cmake for building the whole thing.

        - Create a directory where all generated files will be placed, and
          change to that directory, and generate the Makefiles:

            $ mkdir build && cd build
            $ cmake .. -G "Unix Makefiles"

        - Parallel builds are supported, so, just do (8 == number of
          cores on this machine)
            $ make -j 8

        - We now also support running tests through. Thus, once the
          build is complete, running:

            $ make test

          Will execute all the tests.

        - Once the last step completes (successfully), following
          executable files are generated:

            - build/test/ray-tracer-test ........................ ray tracer tests
            - build/src/ch-02-virtual-cannon .................... trace path of virtual cannonball
            - build/src/ch-04-clock-dial ........................ clock dial using matrix transforms
            - build/src/ch-05-sphere-silhouette ................. silhouette of a sphere
            - build/src/ch-06-st-phong-sphere ................... single-threaded phong-illuminated sphere
            - build/src/ch-06-mt-phong-sphere ................... multi-threaded phong-illuminated sphere
            - build/src/ch-08-making-a-scene .................... single+multi threaded phong-illuminated scene with shadows
            - build/src/ch-09-render-with-plane ................. rendering with a plane
            - build/src/ch-10-render-textures ................... render some textures
            - build/src/ch-10-render-with-patterns .............. render with patterns
            - build/src/ch-10-render-with-textures .............. render with textures

       Just run any program as you would normally.

    B. Brief note on multi-threaded rendtion of various renderers
       ----------------------------------------------------------
       We are using a concurrent mpmc lockless queue, aka 'work-queue'
       for dispatching work items to workers/renderers.

       A 'work-item' comprises 'N' pixels worth of rendering for a
       specific row. 'N' is computed based on
       `std::thread::hardware_concurrency()` i.e. number of h/w cores
       on the machine, and number of x-pixels making up the
       scene.

       A worker picks an item from the queue, and renders all pixels
       specified in the work item. Since all work items (that make up
       the entire canvas) contain disjoint set of pixels, no locking
       is required. Once done with the current work-item, the renderer
       picks up the next one from the queue. This goes on, till all
       the work items in the queue are done.

       Thus, if a machine has 8 physical cores, and the image is
       1280x1024 pixels, 'N' would be '1024 / 8 == 128' pixels. A
       single row is rendered by hopefully in parallel by each h/w
       thread.

       Scenes normally have varying amount of detail, therefore, some
       threads will finish early as compared to their brethren. But
       then they get to pick the next available work item, which can
       tip the balance.

       On the whole though, number of work items handled per thread
       (through the entire course of rendering the scene) should be
       approximately the same.

       Just as an aside, this scheme _seems_ to be a better than
       slicing up the entire scene into multiple stripes, and then
       letting each of the threads handle a specific stripe. Depending
       on the scene, some threads might get a 'free-ride' by just
       rendering stripes that contain few non-black pixels.

    C. Measurement
       -----------
       Once a scene is rendered, we dump the number of milliseconds it
       took, f.e. it looks something like this:

       ,----
       | INFO   | 2020-06-21 12:00:08.576 | /home/anupam/source-code/c++/ray-tracer/src/st_phong_sphere_main.cpp : 00063 | total render time: 848 (ms)
       `----

       Thus, it took '848' milliseconds to render a scene. This is
       '$13' by the way in awk parlance [AWK-REF].

       Multiple such runs (as explained below) are then used to
       compute both the mean, and standard-deviation of rendering
       times for images of various sizes (for both single-threaded and
       multi-threaded renders)

       Statistics[*]:

       | Serial |    Canvas | Single Threaded           | Multi (8) Threaded        | Factor |
       |    No. |      Size | Mean (ms) & Std Deviation | Mean (ms) & Std Deviation |        |
       |--------+-----------+---------------------------+---------------------------+--------|
       |      0 |   640x480 | 217.020000, 9.248762      | 57.630000, 1.163228       |   3.76 |
       |      1 |  1280x960 | 861.040, 25.469558        | 230.310000, 2.115160      |   3.74 |
       |      2 | 1600x1200 | 1358.290000, 46.517587    | 361.050000, 4.441565      |   3.76 |
       |      3 | 1920x1440 | 1958.390000, 63.047267    | 533.970000, 24.884314     |   3.67 |
       |--------+-----------+---------------------------+---------------------------+--------|

       The core of mean+standard deviation numbers reported above are
       computed via the following quickly hacked awk snippet:

       ,---- [ for $13 see AWK-REF above ]
       | awk '{sum += $13; sum_square += $13 * $13} END {mean = sum/NR; std_dev = sqrt(sum_square/NR - (sum/NR)^2); printf("mean:%f, std-dev:%f\n", mean, std_dev)}' | ${log-file}
       `----

       For 100 runs of the program, we do this:

       ,---- [ '100' for 100 samples ]
       |        seq 100 |
       |        while read i
       |        do
       |            ./src/st-phong-sphere 2>&1 | grep 'total render time' &>> st-phong-render.log
       |        done
       `----

       so, the whole thing looks like this:

       ,----[ mt-phong-sphere: 1920x1440 ]
       |        seq 100 |
       |        while read i
       |        do
       |                ./src/st-phong-sphere 2>&1 | grep 'total render time' &>> ${log_fname}
       |        done && awk '{sum += $13; sum_square += $13 * $13} END {mean = sum/NR; std_dev = sqrt(sum_square/NR - (sum/NR)^2); printf("mean:%f, std-dev:%f\n", mean, std_dev)}' ${log_fname}
       |
       |        mean:533.970000, std-dev:24.884314
       `----

       This whole thing can probably be quite easily wrapped in a
       small shell script for automating the whole thing.

       CPU Information [relevant sections from lscpu]
       ----------------------------------------------
       Vendor ID:                       GenuineIntel
       CPU family:                      6
       Model:                           26
       Model name:                      Intel(R) Core(TM) i7 CPU         920  @ 2.67GHz
       Stepping:                        4
       Frequency boost:                 enabled
       CPU MHz:                         2798.166
       CPU max MHz:                     2793.0000
       CPU min MHz:                     1596.0000
       BogoMIPS:                        5331.57
       Virtualization:                  VT-x
       L1d cache:                       128 KiB
       L1i cache:                       128 KiB
       L2 cache:                        1 MiB
       L3 cache:                        8 MiB
       NUMA node0 CPU(s):               0-7
